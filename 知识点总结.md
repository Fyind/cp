## 枚举

先固定一些位置满足某性质

* 1536E, R2300



#### 状态压缩

通过状态压缩可以把枚举的范围变小

* CF1476E, R2300



## 数论



### 同余运算

$$
a \equiv b \quad (\bmod m) \\
2a \equiv 2b \quad (\bmod 2m)
$$

###  最大公因数

$$
gcd(a,b) \quad (\bmod m) \in \{0, m/2\} \quad (m \bmod 2=0) \\
$$

> 推论：当 $a,b$ 是偶数时

$$
gcd(a \bmod 4, b \bmod 4) = gcd(a,b) \bmod 4
$$

* 1548D1, R2300



### 数论分块

#### 优化n^2算法

看似 $O(n^2)$ 实际只有 $O(n\sqrt n)$ 

* CF1603C, R2300





## 数学

### 括号匹配序列

#### 统计序列个数

> 给定一个有 `()` 的序列，求可成为匹配序列的子区间个数

解：开一个map，从1到n统计以 $i$ 结尾的子段。那么需要满足
$$
sum[L,R] = 0 \\
\forall i < R  ,sum[L,i] \ge 0
$$
从小到大枚举 $R$, $map[v]$  统计当前 $sum[L,R]$ 的值为 $v$ 的且满足第二个条件的个数，维护的时候对存储的所有 $sum[L,R-1]$ 加入当前的 $A[R]$每次统计前都删除 $< 0$ 的值，如果 $sum[L,R]<0$ 那么 $L$ 不可能对后面更大的 $R$ 产生贡献。由于我们不关心 $L$ 在哪，只关心值的个数，所以我们只储存值的个数。 

* CF1584E , R2300   



### 最大值与最小值的差(Ad-Hoc)

可以排序后考虑最大值和最小值。若某一个值确定了，那么剩下的值可以贪心的与它距离最小的两个值中选1个, 排序后枚举贪心解决。

考虑答案什么时候可以等于0

* AGC057B



### 鸽巢原理

#### 构造

* CF1552E, R2300, Ad-Hoc. 





### XOR异或

#### 最小异或

> 给定一些数的集合 $S$，$x\ne y\in S$, 求 $x \oplus y$ 最小值

解：把 $S$ 排序，最小值就是排序后相邻元素异或的最小值

* 1625D , R2300





### 位运算求最值

* 1721D



## 组合数学



### 构造集合

构造大小为 $m$ 的集合，可以从 $m-1$ 大小的集合简单转移来, 可以用于DP
$$
C(n,m) =\frac{C(n, m-1)\cdot n}{m}
$$

* ARC146C



#### 可重排列

* 1513E, R2300





## DP

### Convex Hull Trick

* 319C
* 631E



### 区间dp

若干个区间拼成数组，每个区间有范围

* AGC058b



### 树形dp

带条件的dp

* 1453E, R2300



## 图论

### BFS

求最小操作次数

* 1534E, R2300



### 最小生成树

#### 连通区间

让一个区间的点连通，等价于在依次让相邻的点连通。 求相邻点连通就是最小生成树上两点路径。

* CF1706E, R2300



#### Kruskal重构树

还没学

https://www.luogu.com.cn/problem/solution/CF1706E

* CF1706E, R2300



### 拓扑排序

#### 根据拓扑序构造

* 1100E, R2200





## 树



### 树上路径

连接各点的最短路径

* 1594E2, R2300

分析两点的路径

* 1540B, R2300

### 欧拉序

#### 处理子树关系

$u$ 是 $v$ 的儿子等价于 $fr[v] < fr[u] < ed[u] < ed[v] $  也就是 $[fr_u,ed_u]$ 一定被包含在 $[fr_v,ed_v]$ 里面

Set维护叶子结点个数

* 1528C, R2300

#### 欧拉路径序

欧拉序中任意的区间的子树是相互连通的

* 1592D, R2300



## 分治

#### 根据排序分割

* 1601C, R2300





## 贪心



### Cut and paste 

* ABC252F, blue



### 减少条件

若一些复杂条件的成立，那么一定存在一个更小的条件成立

* 1610E, R2300





## 数据结构



### 前缀和

#### 判断若干条件是否成立

若成立，则令值为 $1$, 检查一个区间是否成立，就可以检查前缀和是否为 $0$ 

* 1621E, R2300
* 1721C

#### 维护循环位移

循环位移可以看成是，修改一个元素的位置，然后一个区间的元素左移或者右移。可以提前维护好左移右移的数组。

* 1621E, R2300





### Trie



#### 求最大异或

* 1625D, R2300





### Bitset

实现加/减 $2^k$ , 求高位 $1$. 

* 1705E,  R2300



## 字符串

### 字符串Hash



### KMP

理解求next数组，以及时间复杂度

设 $f[i]$ 是前 $i$ 个字符的最长公共前后缀长度，从已知的向后转移。

$f[1] = 0$

我们已知 $i$ 的匹配了 $f[i]$ 个，设 $j=f[i]$， 如果后面 $t[i]=t[j]$ 也就是下一个字符相等，那么可以直接转移。否则我们要沿着 $j=f[j]$ 找到第一个可以匹配后面字符的位置，因为我们要求的位置已经提前计算过了。若 $j=0$ 则停止。

* 1721E

#### 广义字符串匹配

把暴力判断的条件作为字符串，然后用KMP匹配

* nc14694

### Z函数

从小到大维护的思想，维护 $[l,r]$ 是在 $0\le j<i$, match到的最长的LCP, 我们现在要计算 $z_i$ ， 可以发现 $[l,r]$ 这一段字符和开头是一样的，而开头我们已经计算好了 $z$ 的值，所以可以直接转移，但转移不能超过 $r$ ，因为有可能会匹配的更多。$r-i+1$ 是我们最多允许转移的字符个数，因为超过了这个限制的情况我们不知道，需要重新一个个计算。

| a    | a     | b    | x    | a    | a    | b    | x    | c    | a    | a    | b    |
| ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | $i-l$ |      |      | $l$  | $i$  |      | $r$  |      |      |      |      |

$$
z[i] = \min(z[i-l+1], r-i+1) \quad, r = l+z[l]-1
$$





## 几何

### Shoelace formula

求多边形面积, 每个点 $P_i=(x_i,y_i)$ 逆时针排列
$$
A=\frac{1}{2}\left(x_{1} y_{2}-x_{2} y_{1}+x_{2} y_{3}-x_{3} y_{2}+\cdots+x_{n} y_{1}-x_{1} y_{n}\right)
$$

#### 三角形面积

向量叉积求面积，设 $A=(x_1,y_1), B=(x_2,y_2)$ 求三角形 $OAB$ 
$$
S_{\triangle O A B}=\frac{1}{2}|\overrightarrow{O A} \times \overrightarrow{O B}|=\frac{1}{2}\left|x_{1} y_{2}-x_{2} y_{1}\right|
$$

>  推论：顶点为偶数的三角形面积是偶数



### Pick 定理

顶点是整数点的简单多边形，面积 $A$, 内部点个数 $i$ 边上点个数 $b$ 有关系
$$
A=i+\frac{b}{2}-1
$$

#### 求边上点

两个点 $(x_1,y_1), (x_2,y_2)$ 的边上点的个数是 $gcd(|x_1-x_2|,|y_1-y_2|)$ , （左闭右开形式）

* 1548D1, R2300





## 离线



对于类似可持久化的操作，如果次数要求不多，可以离线统计

* ABC253F, blue